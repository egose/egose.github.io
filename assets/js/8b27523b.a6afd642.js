"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[275],{7964:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>l});var o=n(5893),i=n(1151);n(4866),n(5162),n(9286);const t={sidebar_label:"Philosophy",sidebar_position:0},a="Philosophy",r={id:"egose-acl/philosophy",title:"Philosophy",description:"@egose/acl is a package that provides REST API endpoints for mongoose data models in Express routes. It helps to secure the backend database by decorating mongoose queries with access control lists (ACLs), which are used to restrict access to sensitive data. The package also supports dynamic frontend mongoose-like query options, which allows developers to easily manipulate and query data from the frontend using familiar syntax. By using @egose/acl, developers can streamline their development process and reduce the risk of security breaches caused by unauthorized database access.",source:"@site/docs/egose-acl/philosophy.mdx",sourceDirName:"egose-acl",slug:"/egose-acl/philosophy",permalink:"/docs/egose-acl/philosophy",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_label:"Philosophy",sidebar_position:0},sidebar:"aclSidebar",next:{title:"Quick Start",permalink:"/docs/egose-acl/quick-start"}},c={},l=[{value:"Motivation",id:"motivation",level:2},{value:"Concept",id:"concept",level:2}];function d(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.h1,{id:"philosophy",children:"Philosophy"}),"\n","\n","\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.code,{children:"@egose/acl"})," is a package that provides REST API endpoints for ",(0,o.jsx)(s.a,{href:"https://mongoosejs.com/",children:(0,o.jsx)(s.code,{children:"mongoose"})})," data models in ",(0,o.jsx)(s.a,{href:"https://expressjs.com/",children:(0,o.jsx)(s.code,{children:"Express"})})," routes. It helps to secure the backend database by decorating mongoose queries with access control lists (ACLs), which are used to restrict access to sensitive data. The package also supports dynamic frontend mongoose-like query options, which allows developers to easily manipulate and query data from the frontend using familiar syntax. By using ",(0,o.jsx)(s.code,{children:"@egose/acl"}),", developers can streamline their development process and reduce the risk of security breaches caused by unauthorized database access."]}),"\n",(0,o.jsx)("a",{href:"https://www.npmjs.com/package/@egose/acl",target:"_blank",children:(0,o.jsx)("img",{src:"https://img.shields.io/npm/v/@egose/acl.svg",alt:"NPM Version"})}),"\n",(0,o.jsx)("a",{href:"https://www.npmjs.com/package/@egose/acl",target:"_blank",children:(0,o.jsx)("img",{src:"https://img.shields.io/npm/l/@egose/acl.svg",alt:"Package License"})}),"\n",(0,o.jsx)("a",{href:"https://www.npmjs.com/package/@egose/acl",target:"_blank",children:(0,o.jsx)("img",{src:"https://img.shields.io/npm/dm/@egose/acl.svg",alt:"NPM Downloads"})}),"\n",(0,o.jsx)(s.h2,{id:"motivation",children:"Motivation"}),"\n",(0,o.jsxs)(s.p,{children:["RESTful APIs are widely used today, but they come with some disadvantages. One major challenge is managing object data at a fine-grained level. Consider the example of a User model with multiple fields, including ",(0,o.jsx)(s.code,{children:"name"}),", ",(0,o.jsx)(s.code,{children:"address"}),", ",(0,o.jsx)(s.code,{children:"roles"}),", ",(0,o.jsx)(s.code,{children:"creditBalance"}),", and ",(0,o.jsx)(s.code,{children:"loginDate"}),". When retrieving or updating user entities using RESTful API endpoints, it can be difficult to control which fields are visible or editable depending on the requester's roles."]}),"\n",(0,o.jsxs)(s.p,{children:["For instance, let's say we have an ",(0,o.jsx)(s.code,{children:"admin"})," role that is allowed to read and update all fields of a user entity, while a ",(0,o.jsx)(s.code,{children:"non-admin"})," role is only allowed to read a subset of fields. Excluding fields that ",(0,o.jsx)(s.code,{children:"non-admin"})," is not allowed to read might not be enough, as some fields could be redundant for certain screens. Moreover, sending additional information to the API call, such as ",(0,o.jsx)(s.code,{children:"include=partial[|all]"}),", could lead to a messy backend codebase as the number of fields and screens grows."]}),"\n",(0,o.jsx)(s.p,{children:"The problem becomes even more complex when it comes to updating user entities. Depending on the requester's role, different fields might be editable, and the logic for preventing unwanted updates can quickly become convoluted. This can result in multiple conditional statements in the backend codebase, making it difficult to maintain and scale."}),"\n",(0,o.jsx)(s.p,{children:"To address these challenges, it's worth considering alternative API protocols or standards that might provide more fine-grained control over object data. In addition, it's important to adopt a consistent approach to data management that takes into account the specific needs of different roles and screens. By doing so, it's possible to build more secure and efficient RESTful APIs that can support a wide range of use cases."}),"\n",(0,o.jsx)(s.h2,{id:"concept",children:"Concept"}),"\n",(0,o.jsx)(s.p,{children:"The concept behind this approach is to define a security boundary, in the form of a schema, for each resource that can be accessed via backend routes. By wrapping the request information sent by the browser, this security layer provides the frontend codebase with the flexibility to build queries and manage data within the API endpoints."}),"\n",(0,o.jsx)(s.p,{children:"The library supports object permissions that define whether a user has the ability to perform a specific action on a single object. These permissions are also known as row-level permissions."}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:"Global Permissions"}),"\n",(0,o.jsxs)(s.p,{children:["Global permissions are system-wide and are granted to authenticated users based on their roles. They enable ",(0,o.jsx)(s.code,{children:"role-based access control (RBAC)"})," to the backend system. Global permissions are expected to be provided in the ",(0,o.jsx)(s.code,{children:"Express request object"})," (e.g., ",(0,o.jsx)(s.code,{children:"req._permissions"}),") and are used to enforce access control to the system and resources."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:"Document Permissions"}),"\n",(0,o.jsxs)(s.p,{children:["Document permissions are object-level privileges that define the specific actions that can be performed on a single ",(0,o.jsx)(s.code,{children:"Mongoose document"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:"Role-based Security"}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:"Document-level Security"}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:"Field-level security"}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:"Base Filter"}),"\n",(0,o.jsxs)(s.p,{children:["Base filters are generated to decorate the ",(0,o.jsx)(s.code,{children:"Mongoose Query object"})," and apply global permissions to a target collection."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsx)(s.p,{children:"Mongoose Query Syntax"}),"\n",(0,o.jsxs)(s.p,{children:["The library API endpoints have a similar request structure to the ",(0,o.jsx)(s.code,{children:"Mongoose Syntax"}),", which includes filter, select, and populate options. This helps reduce the learning curve of using the tool."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);